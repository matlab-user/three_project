<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>wdh</title>
		<script src='https://threejs.org/build/three.min.js'></script>
		<script src='https://code.jquery.com/jquery-3.4.1.min.js'></script>
		<script src='js/controls/OrbitControls.js'></script>
		<script src='js/loaders/GLTFLoader.js'></script>
		<script src='js/objects/Lensflare.js'></script>
		<script src="js/libs/stats.min.js"></script>
		
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<div id='WebGL-output'></div>
		<div id='container'></div>
	</body>
	
	<script>
		var ACTION_QUEUE = [];
		var LAST_T = null;				// 上一次更新界面时的时间戳，毫秒
		var START_T = null;
		var if_animate = false;		// 动画定时是否在运行中
		var NEED_RENDER = false;
		var ALWAYS_RENDER = true;		// ==true, 总是持续渲染（鼠标控制时设置为true）
		
		// three.js  坐标系为 右手系
		var render = null;
		var camera = null;
		var scene = null;
		
		var container, stats;
		
		// G - 环绕观察参数
		//	st:		开始时间戳
		//	rad:	转动弧度
		//	ut:		耗时，秒
		// 	r_a:	转轴，vector3
		//	内部使用变量:
		//		init_p:		初始位置
		//		end_p:		结束的位置
		//		speed:		转动速度
		//		rot_rad:	已经转动的距离
		function look_around( camera, G ) {
			// dur_t, t_delta 为毫秒表示的时间
			function __rot( dur_t, t_delta, G_name ) {
				var camera = this.object;
				var G = this.G[ G_name ];
				//camera.matrixAutoUpdate = false;
				
				if ( !G.hasOwnProperty('st') ) {
					G.st = dur_t;
					G.init_p = camera.position;
					G.speed = G.rad / G.ut / 1000;
					G.rot_rad = 0;
					
					var r_vect = new THREE.Vector3( Math.cos(G.rad), 0, Math.sin(G.rad) );
					var cur_vect = G.init_p.clone();
					G.end_p = cur_vect.applyAxisAngle( G.r_a , G.rad );
				}
				else {
					var rad_delta = t_delta * G.speed;
					G.rot_rad += rad_delta;
					if ( G.rot_rad>G.rad )
						var cur_vect = G.end_p;
					else {
						var r_vect = new THREE.Vector3( Math.cos(rad_delta), 0, Math.sin(rad_delta) );
						var cur_vect = camera.position.clone();
						cur_vect.applyAxisAngle( G.r_a, rad_delta );
					}
					camera.position.copy( cur_vect );
					camera.lookAt( scene.position );
					camera.updateMatrixWorld();
					if ( G.rot_rad>G.rad )
						return false;
				}
				return true;
			}
			
			var camera_instance = { 'object':camera, 'G':{'rot':G}, 'rot':__rot };
			start_animate_loop( [ [camera_instance, camera_instance.rot, 'rot'] ] );
		}
		
		// vector, p - three.Vector3, 
		// vector - 非单位向量; p - 旋转轴经过点
		// theta - 转动角度，角度制
		function rot_around_axis( object, vector, p, theta ) {
			var nv = vector.normalize();
			var m_t_p = new THREE.Matrix4();
			var m_rot = new THREE.Matrix4();
			var new_M = new THREE.Matrix4();
			
			m_t_p.setPosition( p.negate() );
			m_rot.makeRotationAxis( nv, theta/180*Math.PI ) ;
			new_M.setPosition( p.negate() ).multiply( m_rot ).multiply( m_t_p ).multiply( object.matrixWorld );
			object.matrix.copy( new_M );
		}
		
		
		function swinging_fun( dur_t, t_detla, G_name ) {
			var status = this.G[G_name];
			if ( !status.hasOwnProperty('start_t') ) {
				status.start_t = Date.now() / 1000;
				return true;
			}
			
			var ut = Date.now()/1000 - status.start_t;
			if ( ut<=status.usage_t ) {
				var should_rad = status.speed * ut;
				var rot_rad = should_rad - status.cur_rad;
				
				rot_around_axis( this.object, status.rot_axis, status.world_p, rot_rad/Math.PI*180 );
				status.cur_rad += rot_rad;

				return true;
			}
			else {
				var rot_rad = status.rad - status.cur_rad;
				rot_around_axis( this.object, status.rot_axis, status.world_p, rot_rad/Math.PI*180 );
				status.cur_times++;
				
				if ( status.times>0 )
					if ( status.cur_times>=status.times )
						return false
					else {
						var times = status.times, p = status.p, usage_t = 3, max_a = Math.random()*20, cur_times = status.cur_times;
						var params = { p:p, times:times, max_a:max_a, usage_t:usage_t, cur_times:cur_times };
					}
				else {
					var times = -1, p = status.p, usage_t = 3, max_a = Math.random()*20;
					var params = { p:p, times:times, max_a:max_a, usage_t:usage_t };
				}
				
				params = init_swinging_params( this, params );
				action_init( this, G_name, params );
				return true;
			}
		}
			
		
		function init_swinging_params( wdh_object_instance, params ) {
			var a = params.max_a / 180 * Math.PI;
			params.max_r = Math.sin( a );
			
			if ( !params.hasOwnProperty('cur_times') )
				params.cur_times = 0;
			
			var c_axis = new THREE.Vector3( 0, 1, 0 ), m4 = new THREE.Matrix4();
			var xa = new THREE.Vector3(), ya = new THREE.Vector3(), za = new THREE.Vector3();
			wdh_object_instance.object.matrixWorld.extractBasis ( xa, ya, za ); 
			m4.makeBasis( xa, ya, za );			
			c_axis.applyMatrix4( m4 );
		
			var mid_a = Math.random() * 2 * Math.PI;
			var mx = params.max_r * Math.cos( mid_a ), mz = params.max_r * Math.sin( mid_a );
			var init_axis = c_axis, end_axis = new THREE.Vector3( mx, Math.cos(a), mz );	
			
			params.rad = init_axis.angleTo( end_axis );		
			params.rot_axis = init_axis.cross( end_axis );
			params.cur_rad = 0;
			params.speed = params.rad / params.usage_t;
			params.world_p = params.p.clone().applyMatrix4( wdh_object_instance.object.matrixWorld );
	
			return params;
		}
		
		// params - { p:转轴经过点(以物体自身坐标系定义，Vector3), max_a:最大晃动半锥角-角度, times:晃动次数, usage_t:单次动作耗时(秒)-和速度相关 }
		// 以下参数为函数自动添加
		// cur_times	当前动作发生次数
		// rot_axis		当前晃动转动轴, 非单位向量
		// start_t		开始时间, 毫秒
		// rad			需要转动的弧度
		// cur_rad		当前已转动弧度
		// speed		运动速度，以每秒
		// max_r		满足半锥角的最大x、y数值
		// world_p		转轴经过点在世界坐标系中的坐标，Vector3
		function swinging( wdh_object_instance, params ) {
			var new_params = init_swinging_params( wdh_object_instance, params );
			action_init( wdh_object_instance, 'swinging', new_params );
			start_animate_loop( [[ wdh_object_instance, swinging_fun, 'swinging']] );
		}
		
		
		// 速度v从0以二次曲线达到峰值v_max，然后再给定时间 t0 内降为0
		// 速度曲线的标准格式为 a*t(t-t0)
		// 保证时间 t0 内移动距离为 S
		function get_v_a( t0, S ) {
			return -6*S / Math.pow(t0, 3);
		}
		
		// 速度曲线为 a*t(t-t0)， t秒后行进的距离
		function get_cur_S( a, t ) {
			return a*Math.pow(t, 3) / -6;
		}
		
		// status - { 'acts':[], 'i':当前执行的动作 }
		function actions_list( dur_t, t_detla, G_name ) {
			var status = this.G[G_name];
			var acts_len = status.acts.length;
			if ( status.i>=acts_len )
				return false;
				
			var i = status.i;
			var obj = status.acts[i][0];
			var fun = status.acts[i][1];
			var params = [dur_t, t_delta];
			params.push( status.acts[i][2] );
			var res = fun.apply( obj, params );
			
			if (res==false) status.i++;
			return true;
		}
		
		// 该函数使用先加速再减速的方式进行物体移动
		// status - { 'move':xxx(vector3), 'usage_t':xx(秒) }
		// 会自动向 states 中增加:
		// 		start_t:		秒
		//		a:				与速度峰值有关的系数
		//		start_M:		执行该动作时的初始位置矩阵
		//		start_pos:		执行该动作时的初始位置向量
		//		move_nv:		归一化的 move 向量
		// move - x,y,z的移动距离
		function smooth_motion( dur_t, t_detla, G_name ) {
			var status = this.G[ G_name ];
			var now = Date.now() / 1000;
			if ( !status.hasOwnProperty('start_t') ) {
				status.start_t = now;
				var pos = new THREE.Vector3();
				var scale = new THREE.Vector3();
				var quaternion = new THREE.Quaternion();
				this.object.matrixWorld.decompose( pos, quaternion, scale );
				var S = status.move.length();
				status.a = get_v_a( status.usage_t, S )
				status.start_M = this.object.matrixWorld.clone();
				status.move_nv = status.move.clone().normalize();
				status.start_pos = pos;
				return true;
			}

			var ut = now - status.start_t;
			if ( ut<=status.usage_t ) {
				var now_S = get_cur_S( status.a, ut );
				var now_pos = status.move_nv.clone().multiplyScalar( now_S );
				var M = status.start_M.clone().setPosition( status.start_pos.clone().add(now_pos) );
				this.object.matrix.copy( M );
				return true;
			}
			else {
				var M = status.start_M.clone().setPosition( status.start_pos.clone().add(status.move) );
				this.object.matrix.copy( M );
				delete this.G[G_name];
				return false;
			}
		}
		
		// params - { 'move':(第一次运动向量，vector3), 'usage_t':xx(秒), 'times':晃动次数 }
		// 根据 i 值自动对 move 反向
		function shake( wdh_object_instance, params ) {
			var act_blocks = [];
			for( var i=0; i<params.times; i++ ) {
				var n = 'act_' + i;
				action_init( wdh_object_instance, n, {'move':params.move.clone(), 'usage_t':params.usage_t} );
				act_blocks.push( [wdh_object_instance, smooth_motion, n] );
				params.move.negate();
			}
			
			action_init( wdh_object_instance, 'acts_list', {'acts':act_blocks, 'i':0} );
			start_animate_loop( [[ wdh_object_instance, actions_list, 'acts_list']] );
		}
		
		
		// 初始化动作参数，以运行某实例的制定动作
		// wdh_object_instance.G[G_name] = params
		function action_init( wdh_object_instance, G_name, params ) {
			wdh_object_instance.G[G_name] = params;
		}
		
		// act_blocks - [ [object, act_fun, params_name], [], .... ]
		function start_animate_loop( act_blocks=null ) {
			if ( act_blocks!=null ) {
				ACTION_QUEUE = ACTION_QUEUE.concat( act_blocks );
				NEED_RENDER = true;
			}
			
			if ( if_animate==false && NEED_RENDER==true || ALWAYS_RENDER==true ) { 
				if_animate = true;
				animate();
			}
		}
		
		var animate = function () {
			if ( ACTION_QUEUE.length==0 && NEED_RENDER==false && ALWAYS_RENDER==false ) {
				if_animate = false;
				return 'if_animate is false';
			}
			
			var now = Date.now();
			if ( START_T==null )
				START_T = now;
			
			if ( LAST_T==null )
				t_delta = 0;
			else
				t_delta = now - LAST_T;
				
			LAST_T = now;
			var dur_t = now - START_T;
			
			var mid_queue = [];
			for (let pack of ACTION_QUEUE ) {
				var obj = pack[0];
				var fun = pack[1];
				var params = [dur_t, t_delta];
				params.push( pack[2] );
			
				var res = fun.apply( obj, params );
				if ( res )
					mid_queue.push( pack )
			}
			
			console.log( mid_queue.length );
			ACTION_QUEUE = mid_queue;
			//controls.update();
			renderer.render( scene, camera );
			NEED_RENDER = false;
			stats.update();
			requestAnimationFrame( animate );
		}

		//------------------------------------------------------------------------------------
		function wdh_object( object, position=null ) {
			this.object = object.clone();
			this.object.matrixAutoUpdate = false;
			
			if ( position!=null ) {
				this.object.position.copy( position );
				this.object.updateMatrix();
			}
			scene.add( this.object );
			
			this.G = { 'init':this.object.matrixWorld.clone() };
			this.move = smooth_motion;
		}
		
	</script>	
		
	<script>
		function init() {
		
			container = $( '#container' );
			
			scene = new THREE.Scene();
			
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.x = -30;
			camera.position.y = 40;
			camera.position.z = 30;
			camera.lookAt( scene.position );
			
			renderer = new THREE.WebGLRenderer();	
			renderer.physicallyCorrectLights = true;
			//renderer.setClearColor( new THREE.Color(0xEEEEEE) );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			
			container[0].appendChild( renderer.domElement );
			stats = new Stats();
			container[0].appendChild( stats.dom );
				
			/*
			//renderer.physicallyCorrectLights = true;
			renderer.setClearColor( new THREE.Color(0xEEEEEE) );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			//renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			//renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.setPixelRatio( window.devicePixelRatio );
			*/
		
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI / 2;
			controls.update();
			
			//添加环境光
			//var ambientLight = new THREE.AmbientLight( 0x0c0c0c );
			//scene.add( ambientLight );
			
			//添加聚光灯光源
			//var spotLight = new THREE.SpotLight( 0xffffff );
			//spotLight.position.set( -40, 60, -10 );
			//spotLight.castShadow = true;
			//scene.add( spotLight );
			
			//hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
			//scene.add( hemiLight );
			
			//var wdh_sphere = new THREE.SphereBufferGeometry( 1, 16, 8 );
			var wdh_sphere = new THREE.TorusBufferGeometry( 1, 0.5, 8, 100 );
			var lensflare = new THREE.Lensflare();
			
			var textureLoader = new THREE.TextureLoader();
			var textureFlare0 = textureLoader.load( 'textures/lensflare/lensflare0.png' );
			var textureFlare3 = textureLoader.load( 'textures/lensflare/lensflare3.png' );
			lensflare.addElement( new THREE.LensflareElement( textureFlare0, 512, 0 ) );
			lensflare.addElement( new THREE.LensflareElement( textureFlare3, 60, 0.6 ) );
	
			light1 = new THREE.PointLight( 0xffffee, 1000, 0, 2 );
			light1.add( new THREE.Mesh( wdh_sphere, new THREE.MeshStandardMaterial( { color: 0xffee88, emissive:0xffffee, emissiveIntensity: 1000} ) ) );
			light1.add( lensflare );
			light1.castShadow = true;
			light1.position.set( 0,20, 0);
			scene.add( light1 );
			
			var bulbGeometry = new THREE.SphereBufferGeometry( 0.2, 16, 8 );
			bulbLight = new THREE.PointLight( 0xffeecc, 1, 100, 2 );
			bulbMat = new THREE.MeshStandardMaterial( {
				emissive: 0xffffee,
				emissiveIntensity: 1,
				color: 0x000000
			} );
			bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
			bulbLight.position.set( 0, 10, 0 );
			bulbLight.castShadow = true;
			scene.add( bulbLight );
				
			var cubeGeometry = new THREE.BoxBufferGeometry( 4, 4, 4 );
			var cubeMaterial = new THREE.MeshLambertMaterial( {color:0xff0000, wireframe:false} );
			cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
			cube.position.x = 0;
			cube.position.y = 2;
			cube.position.z = 0;
			cube.castShadow = true;
			scene.add( cube );
		
			var sphereGeometry = new THREE.SphereBufferGeometry( 4, 20, 20 );
			var sphereMaterial = new THREE.MeshBasicMaterial( {color:0x7777ff, wireframe:true} );
			sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = -10;
			sphere.position.y = 12;
			sphere.position.z = 0;
			sphere.castShadow = true;
			scene.add( sphere );
		
			var planeGeometry = new THREE.PlaneBufferGeometry( 60, 30, 1, 1 );
			var planeMaterial = new THREE.MeshStandardMaterial( {color: 0xffffff,roughness: 0.8, metalness: 0.2, bumpScale: 0.0005} );
			var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			plane.receiveShadow = true;
			plane.rotation.x = -0.5 * Math.PI;
			plane.position.x = 0;
			plane.position.y = 0;
			plane.position.z = 0;
			scene.add( plane );
			
			/*
			var loader = new THREE.GLTFLoader().setPath( './models/' );
			loader.load( 'Flamingo.glb', function ( gltf ) {
				gltf.scene.position.x = 20;
				scene.add( gltf.scene );
			} );
			*/
			
			var geometry = new THREE.BufferGeometry();
			var vertices = new Float32Array( [
				-10, 0, 0,
				0, 10, 0,
				10, 0, 0,
			] );
			geometry.addAttribute( 'position', new THREE.BufferAttribute(vertices, 3) );
			/*
			geometry.vertices.push(
				new THREE.Vector3( -10, 0, 0 ),
				new THREE.Vector3( 0, 10, 0 ),
				new THREE.Vector3( 10, 0, 0 )
			);
			*/
			var material = new THREE.LineBasicMaterial({
				color: 0x0000ff
			});
			var line = new THREE.Line( geometry, material );
			scene.add( line );
				
			var geometry = new THREE.BufferGeometry();
			var vertices = new Float32Array( [
				0, 0, 0,
				0, 15, 0,
			] );
			geometry.addAttribute( 'position', new THREE.BufferAttribute(vertices, 3) );
			
			/*
			geometry.vertices.push(
				new THREE.Vector3( 0, 0, 0 ),
				new THREE.Vector3( 0, 15, 0 ),
			);
			*/
			var material = new THREE.LineBasicMaterial({
				color: 0xff00ff
			});
			swing_line = new THREE.Line( geometry, material );
			
			for ( var i=0; i<100; i++ ) {
				var geometry = new THREE.BufferGeometry();
				var vertices = new Float32Array( [
					0, 0, 0,
					(Math.random()*2-1)*1, 15, (Math.random()*2-1)*1,
				] );
				geometry.addAttribute( 'position', new THREE.BufferAttribute(vertices, 3) );
				/*
				geometry.vertices.push(
					new THREE.Vector3( 0, 0, 0 ),
					new THREE.Vector3( (Math.random()*2-1)*1, 15, (Math.random()*2-1)*1 ),
				);
				*/
				swing_line.add( new THREE.Line(geometry, material) );
			}
			
			var pos = new THREE.Vector3( 10, 0, 0 );
			wdh_swing_line = new wdh_object( swing_line, pos );
			
			$('#WebGL-output')[0].appendChild( renderer.domElement );
			renderer.render( scene, camera );
		}	
	</script>
	
	<script>
		$( function() {
			init();
			//console.log( cube.geometry.vertices[0] );
			//console.log( cube.geometry.faces );
			//return;
			wdh_cube = new wdh_object( cube );
		
			//G = { 'rad':3*Math.PI, 'ut':8, 'r_a':new THREE.Vector3(0,1,0) }
			//look_around( camera, G );
			
			$('#WebGL-output').click( function( e ) {
				e.preventDefault();
			
				var self = $( this );
				var W = self.innerWidth();
				var H = self.innerHeight();
							
				var x = ( e.pageX / W ) * 2 - 1;
				var y = -( e.pageY / H ) * 2 + 1;	
				var vet = new THREE.Vector3( x, y, 0.5 );
				
				var objects = [sphere, cube, wdh_cube.object];
				
				vet = vet.unproject( camera );
				//console.log( 'need_render:', NEED_RENDER, 'if_animate:', if_animate );
				
				var raycaster = new THREE.Raycaster( camera.position, vet.sub(camera.position).normalize() );		
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length>0 ) {
					intersects[0].object.material.transparent = true;
					intersects[0].object.material.opacity = 0.2;
					NEED_RENDER = true;
				}
				else {
					objects.forEach( function( item ) {
						item.material.opacity = 1;
						NEED_RENDER = true;
					} )
				}
				
				if ( NEED_RENDER==true )
					start_animate_loop();
			} );
			
			/*
			action_init( wdh_cube, 'act_1', {'move':new THREE.Vector3(20,0,0), 'usage_t':0.2} );
			action_init( wdh_cube, 'act_2', {'move':new THREE.Vector3(-20,0,0), 'usage_t':0.3} );
			action_init( wdh_cube, 'act_3', {'move':new THREE.Vector3(16,0,0), 'usage_t':0.4} );
			action_init( wdh_cube, 'act_4', {'move':new THREE.Vector3(-16,0,0), 'usage_t':0.4} );
			
			var act_blocks = [];
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_1'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_2'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_3'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_4'] );
			action_init( wdh_cube, 'acts_list', {'acts':act_blocks, 'i':0} );
			
			start_animate_loop( [[wdh_cube, actions_list, 'acts_list']] );
			*/
			
			//shake( wdh_cube, {'move':new THREE.Vector3(20,8,9), 'times':200,'usage_t':1} );
			
			var params = { p:new THREE.Vector3(0,0,0), times:200, max_a:10, usage_t:1 }
			swinging( wdh_swing_line, params );
		} )
	</script>
	
</html>