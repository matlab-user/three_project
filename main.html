<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>wdh</title>
		<script src='https://threejs.org/build/three.min.js'></script>
		<script src='https://code.jquery.com/jquery-3.4.1.min.js'></script>
		<script src='js/controls/OrbitControls.js'></script>
		<script src="js/loaders/GLTFLoader.js"></script>
		
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<div id='WebGL-output'></div>
	</body>
	
	<script>
		var ACTION_QUEUE = [];
		var LAST_T = null;				// 上一次更新界面时的时间戳，毫秒
		var START_T = null;
		var if_animate = false;		// 动画定时是否在运行中
		var NEED_RENDER = false;
		var ALWAYS_RENDER = true;		// ==true, 总是持续渲染（鼠标控制时设置为true）
		
		// three.js  坐标系为 右手系
		var render = null;
		var camera = null;
		var scene = null;
		
		// G - 环绕观察参数
		//	st:		开始时间戳
		//	rad:	转动弧度
		//	ut:		耗时，秒
		// 	r_a:	转轴，vector3
		//	内部使用变量:
		//		init_p:		初始位置
		//		end_p:		结束的位置
		//		speed:		转动速度
		//		rot_rad:	已经转动的距离
		function look_around( camera, G ) {
			// dur_t, t_delta 为毫秒表示的时间
			function __rot( dur_t, t_delta, G_name ) {
				var camera = this.object;
				var G = this.G[ G_name ];
				//camera.matrixAutoUpdate = false;
				
				if ( !G.hasOwnProperty('st') ) {
					G.st = dur_t;
					G.init_p = camera.position;
					G.speed = G.rad / G.ut / 1000;
					G.rot_rad = 0;
					
					var r_vect = new THREE.Vector3( Math.cos(G.rad), 0, Math.sin(G.rad) );
					var cur_vect = G.init_p.clone();
					G.end_p = cur_vect.applyAxisAngle( G.r_a , G.rad );
				}
				else {
					var rad_delta = t_delta * G.speed;
					G.rot_rad += rad_delta;
					if ( G.rot_rad>G.rad )
						var cur_vect = G.end_p;
					else {
						var r_vect = new THREE.Vector3( Math.cos(rad_delta), 0, Math.sin(rad_delta) );
						var cur_vect = camera.position.clone();
						cur_vect.applyAxisAngle( G.r_a, rad_delta );
					}
					camera.position.copy( cur_vect );
					camera.lookAt( scene.position );
					camera.updateMatrixWorld();
					if ( G.rot_rad>G.rad )
						return false;
				}
				return true;
			}
			
			var camera_instance = { 'object':camera, 'G':{'rot':G}, 'rot':__rot };
			start_animate_loop( [ [camera_instance, camera_instance.rot, 'rot'] ] );
		}
		
		// vector, p - three.Vector3, 
		// vector - 非单位向量; p - 旋转轴经过点
		// theta - 转动角度，角度制
		function rot_around_axis( object, vector, p, theta ) {
			var nv = vector.normalize();
			var m_t_p = new THREE.Matrix4();
			var m_rot = new THREE.Matrix4();
			var new_M = new THREE.Matrix4();
			
			m_t_p.setPosition( p.negate() );
			m_rot.makeRotationAxis( nv, theta/180*Math.PI ) ;
			new_M.setPosition( p.negate() ).multiply( m_rot ).multiply( m_t_p ).multiply( object.matrixWorld );
			
			object.matrix = new_M;
		}
			
		// 速度v从0以二次曲线达到峰值v_max，然后再给定时间 t0 内降为0
		// 速度曲线的标准格式为 a*t(t-t0)
		// 保证时间 t0 内移动距离为 S
		function get_v_a( t0, S ) {
			return -6*S / Math.pow(t0, 3);
		}
		
		// 速度曲线为 a*t(t-t0)， t秒后行进的距离
		function get_cur_S( a, t ) {
			return a*Math.pow(t, 3) / -6;
		}
		
		// status - { 'acts':[], 'i':当前执行的动作 }
		function actions_list( dur_t, t_detla, G_name ) {
			var status = this.G[G_name];
			var acts_len = status.acts.length;
			if ( status.i>=acts_len )
				return false;
				
			var i = status.i;
			var obj = status.acts[i][0];
			var fun = status.acts[i][1];
			var params = [dur_t, t_delta];
			params.push( status.acts[i][2] );
			var res = fun.apply( obj, params );
			
			if (res==false) status.i++;
			return true;
		}
		
		// 该函数使用先加速再减速的方式进行物体移动
		// status - { 'move':xxx(vector3), 'usage_t':xx(秒) }
		// 会自动向 states 中增加:
		// 		start_t:		秒
		//		a:				与速度峰值有关的系数
		//		start_M:		执行该动作时的初始位置矩阵
		//		start_pos:		执行该动作时的初始位置向量
		//		move_nv:		归一化的 move 向量
		// move - x,y,z的移动距离
		function smooth_motion( dur_t, t_detla, G_name ) {
			var status = this.G[ G_name ];
			var now = Date.now() / 1000;
			if ( !status.hasOwnProperty('start_t') ) {
				status.start_t = now;
				var pos = new THREE.Vector3();
				var scale = new THREE.Vector3();
				var quaternion = new THREE.Quaternion();
				this.object.matrixWorld.decompose( pos, quaternion, scale );
				var S = status.move.length();
				status.a = get_v_a( status.usage_t, S )
				status.start_M = this.object.matrixWorld.clone();
				status.move_nv = status.move.clone().normalize();
				status.start_pos = pos;
				return true;
			}

			var ut = now - status.start_t;
			if ( ut<=status.usage_t ) {
				var now_S = get_cur_S( status.a, ut );
				var now_pos = status.move_nv.clone().multiplyScalar( now_S );
				var M = status.start_M.clone().setPosition( status.start_pos.clone().add(now_pos) );
				this.object.matrix.copy( M );
				return true;
			}
			else {
				var M = status.start_M.clone().setPosition( status.start_pos.clone().add(status.move) );
				this.object.matrix.copy( M );
				delete this.G[G_name];
				return false;
			}
		}
		
		// params - { 'move':(第一次运动向量，vector3), 'usage_t':xx(秒), 'times':晃动次数 }
		// 根据 i 值自动对 move 反向
		function shake( wdh_object_instance, params ) {
			var act_blocks = [];
			for( var i=0; i<params.times; i++ ) {
				var n = 'act_' + i;
				action_init( wdh_object_instance, n, {'move':params.move.clone(), 'usage_t':params.usage_t} );
				act_blocks.push( [wdh_object_instance, smooth_motion, n] );
				params.move.negate();
			}
			
			action_init( wdh_object_instance, 'acts_list', {'acts':act_blocks, 'i':0} );
			start_animate_loop( [[ wdh_object_instance, actions_list, 'acts_list']] );
		}
		
		
		// 初始化动作参数，以运行某实例的制定动作
		// wdh_object_instance.G[G_name] = params
		function action_init( wdh_object_instance, G_name, params ) {
			wdh_object_instance.G[G_name] = params;
		}
		
		// act_blocks - [ [object, act_fun, params_name], [], .... ]
		function start_animate_loop( act_blocks=null ) {
			if ( act_blocks!=null ) {
				ACTION_QUEUE = ACTION_QUEUE.concat( act_blocks );
				NEED_RENDER = true;
			}
			
			if ( if_animate==false && NEED_RENDER==true || ALWAYS_RENDER==true ) { 
				if_animate = true;
				animate();
			}
		}
		
		var animate = function () {
			if ( ACTION_QUEUE.length==0 && NEED_RENDER==false && ALWAYS_RENDER==false ) {
				if_animate = false;
				return 'if_animate is false';
			}
			
			var now = Date.now();
			if ( START_T==null )
				START_T = now;
			
			if ( LAST_T==null )
				t_delta = 0;
			else
				t_delta = now - LAST_T;
				
			LAST_T = now;
			var dur_t = now - START_T;
			
			var mid_queue = [];
			for (let pack of ACTION_QUEUE ) {
				var obj = pack[0];
				var fun = pack[1];
				var params = [dur_t, t_delta];
				params.push( pack[2] );
			
				var res = fun.apply( obj, params );
				if ( res )
					mid_queue.push( pack )
			}
			
			ACTION_QUEUE = mid_queue;
			controls.update();
			renderer.render( scene, camera );
			NEED_RENDER = false;
			requestAnimationFrame( animate );
			
		}

		//------------------------------------------------------------------------------------
		function wdh_object( object, position=null ) {
			this.object = object.clone();
			scene.add( this.object );
			this.object.matrixAutoUpdate = false;
		
			this.G = { 'init':this.object.matrixWorld.clone() };
			this.move = smooth_motion;
		}
		
	</script>	
		
	<script>
		function init() {
			scene = new THREE.Scene();
			
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.x = -30;
			camera.position.y = 40;
			camera.position.z = 30;
			camera.lookAt( scene.position );
			
			renderer = new THREE.WebGLRenderer();	
			//renderer.physicallyCorrectLights = true;
			renderer.setClearColor( new THREE.Color(0xEEEEEE) );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			/*
			//renderer.physicallyCorrectLights = true;
			renderer.setClearColor( new THREE.Color(0xEEEEEE) );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			//renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			//renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.setPixelRatio( window.devicePixelRatio );
			*/
		
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI / 2;
			controls.update();
			
			//添加环境光
			var ambientLight = new THREE.AmbientLight( 0x0c0c0c );
			scene.add( ambientLight );
			
			//添加聚光灯光源
			//var spotLight = new THREE.SpotLight( 0xffffff );
			//spotLight.position.set( -40, 60, -10 );
			//spotLight.castShadow = true;
			//scene.add( spotLight );
			
			hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
			scene.add( hemiLight );
			
			var bulbGeometry = new THREE.SphereBufferGeometry( 0.02, 16, 8 );
			bulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );
			bulbMat = new THREE.MeshStandardMaterial( {
				emissive: 0xffffee,
				emissiveIntensity: 1,
				color: 0x000000
			} );
			bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
			bulbLight.position.set( 0, 20, 0 );
			bulbLight.castShadow = true;
			scene.add( bulbLight );
			
				
			var cubeGeometry = new THREE.BoxGeometry( 4, 4, 4 );
			var cubeMaterial = new THREE.MeshLambertMaterial( {color:0xff0000, wireframe:false} );
			cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
			cube.position.x = 0;
			cube.position.y = 2;
			cube.position.z = 0;
			cube.castShadow = true;
			scene.add( cube );
		
			var sphereGeometry = new THREE.SphereGeometry( 4, 20, 20 );
			var sphereMaterial = new THREE.MeshBasicMaterial( {color:0x7777ff, wireframe:true} );
			sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = -10;
			sphere.position.y = 12;
			sphere.position.z = 0;
			sphere.castShadow = true;
			scene.add( sphere );
		
			var planeGeometry = new THREE.PlaneGeometry( 60, 30, 1, 1 );
			var planeMaterial = new THREE.MeshStandardMaterial( {color: 0xffffff,roughness: 0.8, metalness: 0.2, bumpScale: 0.0005} );
			var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			plane.receiveShadow = true;
			plane.rotation.x = -0.5 * Math.PI;
			plane.position.x = 0;
			plane.position.y = 0;
			plane.position.z = 0;
			scene.add( plane );
			
			var loader = new THREE.GLTFLoader().setPath( './models/' );
			loader.load( 'Flamingo.glb', function ( gltf ) {
				gltf.scene.position.x = 20;
				scene.add( gltf.scene );
			} );
			
		
			$('#WebGL-output')[0].appendChild( renderer.domElement );
			renderer.render( scene, camera );
		}	
	</script>
	
	<script>
		$( function() {
			init();
			wdh_cube = new wdh_object( cube );
			
			G = { 'rad':0*Math.PI, 'ut':5, 'r_a':new THREE.Vector3(0,1,0) }
			look_around( camera, G );
			
			$('#WebGL-output').click( function( e ) {
				e.preventDefault();
			
				var self = $( this );
				var W = self.innerWidth();
				var H = self.innerHeight();
							
				var x = ( e.pageX / W ) * 2 - 1;
				var y = -( e.pageY / H ) * 2 + 1;	
				var vet = new THREE.Vector3( x, y, 0.5 );
				
				var objects = [sphere, cube, wdh_cube.object];
				
				vet = vet.unproject( camera );
				console.log( 'need_render:', NEED_RENDER, 'if_animate:', if_animate );
				
				var raycaster = new THREE.Raycaster( camera.position, vet.sub(camera.position).normalize() );		
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length>0 ) {
					intersects[0].object.material.transparent = true;
					intersects[0].object.material.opacity = 0.2;
					NEED_RENDER = true;
				}
				else {
					objects.forEach( function( item ) {
						item.material.opacity = 1;
						NEED_RENDER = true;
					} )
				}
				
				if ( NEED_RENDER==true )
					start_animate_loop();
			} );
			
			/*
			action_init( wdh_cube, 'act_1', {'move':new THREE.Vector3(20,0,0), 'usage_t':0.2} );
			action_init( wdh_cube, 'act_2', {'move':new THREE.Vector3(-20,0,0), 'usage_t':0.3} );
			action_init( wdh_cube, 'act_3', {'move':new THREE.Vector3(16,0,0), 'usage_t':0.4} );
			action_init( wdh_cube, 'act_4', {'move':new THREE.Vector3(-16,0,0), 'usage_t':0.4} );
			
			var act_blocks = [];
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_1'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_2'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_3'] );
			act_blocks.push( [wdh_cube, wdh_cube.move, 'act_4'] );
			action_init( wdh_cube, 'acts_list', {'acts':act_blocks, 'i':0} );
			
			start_animate_loop( [[wdh_cube, actions_list, 'acts_list']] );
			*/
			
			shake( wdh_cube, {'move':new THREE.Vector3(20,8,9), 'times':8,'usage_t':1} );
		} )
	</script>
	
</html>