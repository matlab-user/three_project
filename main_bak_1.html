<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>wdh</title>
		<script src='https://threejs.org/build/three.min.js'></script>
		<script src='https://code.jquery.com/jquery-3.4.1.min.js'></script>
		
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<div id='WebGL-output'></div>
	</body>
	
	<script>
		var ACTION_QUEUE = [];
		var LAST_T = null;				// 上一次更新界面时的时间戳，毫秒
		var START_T = null;
		var if_animate = false;
	
		// three.js  坐标系为 右手系
		var render = null;
		var camera = null;
		var scene = null;
		
		// vector, p - three.Vector3, 
		// vector - 非单位向量; p - 旋转轴经过点
		// theta - 转动角度，角度制
		function rot_around_axis( object, vector, p, theta ) {
			var nv = vector.normalize();
			var m_t_p = new THREE.Matrix4();
			var m_rot = new THREE.Matrix4();
			var new_M = new THREE.Matrix4();
			
			m_t_p.setPosition( p.negate() );
			m_rot.makeRotationAxis( nv, theta/180*Math.PI ) ;
			new_M.setPosition( p.negate() ).multiply( m_rot ).multiply( m_t_p ).multiply( object.matrixWorld );
			
			object.matrix = new_M;
		}
		
		
		function object_move( object, new_pos ) {
			object.matrix.setPosition( new_pos )
			renderer.render( scene, camera );
		}
		
		function wdh_object( object ) {
			this.object = object.clone();
			scene.add( this.object );
			
			this.object.matrixAutoUpdate = false;
			this.G = { 'init':this.object.matrixWorld.clone() };
				
			this.open = function( dur_t, t_detla, status ) {
				if ( dur_t<status.start_t )
					return true;
					
				this.object.translateX( 0.1 );
				this.object.updateMatrix();
			
				status.cur_t++;
				if ( status.cur_t>status.times ) {
					status.cur_t = 0;
					this.action_callback( 'open' );
					return false;
				}
				else
					return true;
			};
			
			this.action_callback = function( act_name ) {
				console.log( this.G.open );
			};
		}
	
		var animate = function () {		
			if ( ACTION_QUEUE.length==0 ) {
				if_animate = false;
				return 'if_animate is false';
			}
			
			var now = Date.now();
			if ( START_T==null )
				START_T = now;
			
			if ( LAST_T==null )
				t_delta = 0;
			else
				t_delta = now - LAST_T;
				
			LAST_T = now;
			var dur_t = now - START_T;
	
			var mid_queue = [];
			for (let pack of ACTION_QUEUE ) {
				var obj = pack[0];
				var fun = pack[1];
				var params = [dur_t, t_delta];
				params.push( pack[2] );
			
				var res = fun.apply( obj, params );
				if ( res )
					mid_queue.push( pack )
			}
			
			ACTION_QUEUE = mid_queue;
			
			renderer.render( scene, camera );
			requestAnimationFrame( animate );
		}

	</script>	
		
	<script>
		function init() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
 
			camera.position.x = -30;
			camera.position.y = 40;
			camera.position.z = 30;
			camera.lookAt( scene.position );
			
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor( new THREE.Color(0xEEEEEE) );
			renderer.setSize( window.innerWidth, window.innerHeight );
			
			//添加环境光
			var ambientLight = new THREE.AmbientLight( 0x0c0c0c );
			scene.add( ambientLight );
			
			//添加聚光灯光源
			var spotLight = new THREE.SpotLight( 0xffffff );
			spotLight.position.set( -30, 60, -10 );
			spotLight.castShadow = true;
			scene.add( spotLight );

		
			var cubeGeometry = new THREE.BoxGeometry( 4, 4, 4 );
			var cubeMaterial = new THREE.MeshBasicMaterial( {color:0xff0000, wireframe:false} );
			cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
			cube.position.x = 20;
			cube.position.y = 0;
			cube.position.z = 0;
			scene.add( cube );
			
			var sphereGeometry = new THREE.SphereGeometry( 4, 20, 20 );
			var sphereMaterial = new THREE.MeshBasicMaterial( {color:0x7777ff, wireframe:true} );
			sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			sphere.position.x = 0;
			sphere.position.y = 0;
			sphere.position.z = 0;
			scene.add( sphere );
		
			var planeGeometry = new THREE.PlaneGeometry( 60, 30, 1, 1 );
			var planeMaterial = new THREE.MeshLambertMaterial( {color: 0xffffff} );
			var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			plane.receiveShadow = true;
			plane.rotation.x = -0.5 * Math.PI;
			plane.position.x = 0;
			plane.position.y = 0;
			plane.position.z = 0;
			scene.add( plane );
			
			$('#WebGL-output')[0].appendChild( renderer.domElement );
			renderer.render( scene, camera );
		}	
	</script>
	
	<script>
		$( function() {
			init();
			var wdh_cube_1 = new wdh_object( cube );
			var wdh_cube_2 = new wdh_object( cube );
			wdh_cube_1.G.open = { 'times':300, 'cur_t':0, 'start_t':10 }
			wdh_cube_2.G.open = { 'times':100, 'cur_t':0, 'start_t':2000 } 	
			ACTION_QUEUE.push( [wdh_cube_1, wdh_cube_1.open, wdh_cube_1.G.open], [wdh_cube_2, wdh_cube_2.open, wdh_cube_2.G.open] );
			animate();
			/*
			var vector = new THREE.Vector3( 0, 1, 1 );
			var p = new THREE.Vector3( 0, 1, 0 );
			rot_around_axis( cube, vector, p, 10 );
			renderer.render( scene, camera );
			*/
		
		} )
	</script>
	
</html>